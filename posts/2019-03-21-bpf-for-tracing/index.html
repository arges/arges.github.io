<!doctype html><html lang><head><link rel=preload href=/chrisarges.net/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/chrisarges.net/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/chrisarges.net/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/chrisarges.net/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><script type=text/javascript src=https://latest.cactus.chat/cactus.js></script>
<link rel=stylesheet href=https://latest.cactus.chat/style.css type=text/css><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>bpf for linux tracing |</title><link rel=canonical href=chrisarges.net/posts/2019-03-21-bpf-for-tracing/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="bpf for linux tracing"><meta property="og:description" content="Overview Originally called eBPF for extended Berkeley Packet Filter, BPF is an in-kernel bytecode interpreter that is very multi-purpose. In this post, I&rsquo;m going to focus on its tracing capabilities.
To use BPF one can use the bpf syscall. This provides a way to both load BPF bytecode programs and also create memory maps for sharing data between kernel and user space.
Because of the complexity, using bpf in a DIY method becomes a bit complex."><meta property="og:type" content="article"><meta property="og:url" content="chrisarges.net/posts/2019-03-21-bpf-for-tracing/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-03-21T11:54:37-05:00"><meta property="article:modified_time" content="2019-03-21T11:54:37-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="bpf for linux tracing"><meta name=twitter:description content="Overview Originally called eBPF for extended Berkeley Packet Filter, BPF is an in-kernel bytecode interpreter that is very multi-purpose. In this post, I&rsquo;m going to focus on its tracing capabilities.
To use BPF one can use the bpf syscall. This provides a way to both load BPF bytecode programs and also create memory maps for sharing data between kernel and user space.
Because of the complexity, using bpf in a DIY method becomes a bit complex."><link rel=stylesheet href=/chrisarges.net/css/styles.c05d68261bf086a9d7713c4f8a6215a3601608e267a816a7ee58f139b3d1aae51222aae2081c8e0c6bd35e1334773b7a16283022f31f92afd93bb37e5e822e66.css integrity="sha512-wF1oJhvwhqnXcTxPimIVo2AWCOJnqBan7ljxObPRquUSIqriCByODGvTXhM0dzt6FigwIvMfkq/ZO7N+XoIuZg=="><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=chrisarges.net/images/favicon.ico></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=top-icon-tablet href=# onclick='$("html, body").animate({scrollTop:0},"fast")' style=display:none aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg"></i></a>
<span id=menu><span id=nav><ul><li><a href=chrisarges.net/>Home</a></li><li><a href=chrisarges.net/about>About</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=chrisarges.net/posts/2019-01-14-the-magic-of-linux-clone/ aria-label=Previous><i class="fas fa-chevron-left" aria-hidden=true onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class=icon href=chrisarges.net/posts/2019-07-16-openssh-install-on-windows/ aria-label=Next><i class="fas fa-chevron-right" aria-hidden=true onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class=icon href=# onclick='$("html, body").animate({scrollTop:0},"fast")' aria-label="Top of Page"><i class="fas fa-chevron-up" aria-hidden=true onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class=icon href=# aria-label=Share><i class="fas fa-share-alt" aria-hidden=true onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f" aria-label=Facebook><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&text=bpf%20for%20linux%20tracing" aria-label=Twitter><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&title=bpf%20for%20linux%20tracing" aria-label=Linkedin><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&is_video=false&description=bpf%20for%20linux%20tracing" aria-label=Pinterest><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=bpf%20for%20linux%20tracing&body=Check out this article: chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f" aria-label=Email><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&title=bpf%20for%20linux%20tracing" aria-label=Pocket><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&title=bpf%20for%20linux%20tracing" aria-label=reddit><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&name=bpf%20for%20linux%20tracing&description=Overview%20Originally%20called%20eBPF%20for%20extended%20Berkeley%20Packet%20Filter%2c%20BPF%20is%20an%20in-kernel%20bytecode%20interpreter%20that%20is%20very%20multi-purpose.%20In%20this%20post%2c%20I%26rsquo%3bm%20going%20to%20focus%20on%20its%20tracing%20capabilities.%0aTo%20use%20BPF%20one%20can%20use%20the%20bpf%20syscall.%20This%20provides%20a%20way%20to%20both%20load%20BPF%20bytecode%20programs%20and%20also%20create%20memory%20maps%20for%20sharing%20data%20between%20kernel%20and%20user%20space.%0aBecause%20of%20the%20complexity%2c%20using%20bpf%20in%20a%20DIY%20method%20becomes%20a%20bit%20complex." aria-label=Tumblr><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&t=bpf%20for%20linux%20tracing" aria-label="Hacker News"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">bpf for linux tracing</h1><div class=meta><div class=postdate><time datetime="2019-03-21 11:54:37 -0500 -0500" itemprop=datePublished>2019-03-21</time></div><div class=article-tag><i class="fas fa-tag"></i>
<a class=tag-link href=/tags/linux rel=tag>linux</a>
,
<a class=tag-link href=/tags/kernel rel=tag>kernel</a>
,
<a class=tag-link href=/tags/bpf rel=tag>bpf</a>
,
<a class=tag-link href=/tags/tracing rel=tag>tracing</a></div></div></header><div id=toc><nav id=TableOfContents><ul><li><a href=#overview>Overview</a></li></ul><ul><li><a href=#features-supported-in-linux-kernel-versions>Features Supported in Linux Kernel Versions</a></li><li><a href=#limitations>Limitations</a></li></ul><ul><li><a href=#bpf-tracing-performance>BPF Tracing Performance</a></li></ul></nav></div><div class=content itemprop=articleBody><h2 id=overview>Overview</h2><p>Originally called eBPF for extended Berkeley Packet Filter, BPF is an in-kernel
bytecode interpreter that is very multi-purpose. In this post, I&rsquo;m going to
focus on its tracing capabilities.</p><p>To use BPF one can use the bpf <a href=http://man7.org/linux/man-pages/man2/bpf.2.html>syscall</a>. This provides a way to both load
BPF bytecode programs and also create memory maps for sharing data between
kernel and user space.</p><p>Because of the complexity, using bpf in a DIY method becomes a bit complex.
There are many ready to use tools such as <a href=https://github.com/iovisor/bcc>BCC</a> and libbpf that make usage
way easier.</p><h1 id=ready-to-use-bpf-via-bcc>Ready to Use BPF via BCC</h1><p>The <code>bcc</code> project makes it easy to use BPF via a python program.</p><p>To use, first install dependencies:</p><pre tabindex=0><code>sudo apt-get install bpfcc-tools linux-headers-$(uname -r)
</code></pre><p>Next, create a python file named trace.py:</p><pre tabindex=0><code>#!/usr/bin/python
from bcc import BPF

b = BPF(text=&#34;&#34;&#34;
TRACEPOINT_PROBE(raw_syscalls, sys_exit) {
    u64 pid_tgid = bpf_get_current_pid_tgid();
    u64 uid_gid = bpf_get_current_uid_gid();
    bpf_trace_printk(&#34;SYS_EXIT tgid:%ld pid:%ld uid:%ld\\n&#34;, pid_tgid &gt;&gt; 32 &amp; 0xffff, pid_tgid &amp; 0xffff, uid_gid &gt;&gt; 32 &amp; 0xf
fff);
}
&#34;&#34;&#34;)

print(&#34;%-18s %-16s %-6s %s&#34; % (&#34;TIME(s)&#34;, &#34;COMM&#34;, &#34;PID&#34;, &#34;EVENT&#34;))
while 1:
    try:
        (task, pid, cpu, flags, ts, msg) = b.trace_fields()
    except ValueError:
        continue
    print(&#34;%-18.9f %-16s %-6d %s&#34; % (ts, task, pid, msg))
</code></pre><p>Then run it:</p><pre tabindex=0><code>sudo python trace.py
</code></pre><p>And magically it spits out text like:</p><pre tabindex=0><code>32508.991461000   python           21303  00000001: SYS_EXIT tgid:21303 pid:21303 uid:0
32508.991468000   python           21303  00000001: SYS_EXIT tgid:21303 pid:21303 uid:0
32508.991475000   python           21303  00000001: SYS_EXIT tgid:21303 pid:21303 uid:0
32508.991482000   python           21303  00000001: SYS_EXIT tgid:21303 pid:21303 uid:0
32508.991490000   python           21303  00000001: SYS_EXIT tgid:21303 pid:21303 uid:0
</code></pre><p>All this is attaching to a raw tracepoint and printing out some data related to
that process. The python library is taking the text and compiling it to BPF
bytecode and handling allocation of maps. Then its calling the <code>bpf</code> syscall to
create maps and insert the program. And in addition it is taking the data from
the map and printing it to the screen.</p><p>An strace of the python program reveals the following:</p><pre tabindex=0><code>bpf(BPF_PROG_LOAD, {prog_type=BPF_PROG_TYPE_TRACEPOINT, insn_cnt=32, insns=0x7f259141b7d0, license=&#34;GPL&#34;, log_level=0, log_size=0, log_buf=0, kern_version=266002, prog_flags=0, ...}, 64) = 3
</code></pre><h1 id=diy-bpf>DIY BPF</h1><p>There are many ways to create a BPF program. One method as described above uses
C code with many helper functions and then compiles to bytecode and is
inserted. Another method would be writing bytecode directly using assembler
like macros:</p><pre tabindex=0><code>BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /* r2 = fp */
BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /* r2 = r2 - 4 */
BPF_LD_MAP_FD(BPF_REG_1, map_fd),           /* r1 = map_fd */
BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),
</code></pre><p>Using C directly and having a compiler like <code>clang</code> with a BPF target makes
writing your own BPF program slightly easier. However the loading part becomes
a bit more complex. Once you&rsquo;ve created a bpf object file you&rsquo;ll have to use
<code>libbpf</code> or write your own loader that can convert the ELF object into the
correct structures for the BPF syscall. These structures can be a program or
maps and each has different types depending on your BPF program.</p><p>For reference here are the program types (as of Linux v5.0):</p><pre tabindex=0><code>enum bpf_prog_type {
	BPF_PROG_TYPE_UNSPEC,
	BPF_PROG_TYPE_SOCKET_FILTER,
	BPF_PROG_TYPE_KPROBE,
	BPF_PROG_TYPE_SCHED_CLS,
	BPF_PROG_TYPE_SCHED_ACT,
	BPF_PROG_TYPE_TRACEPOINT,
	BPF_PROG_TYPE_XDP,
	BPF_PROG_TYPE_PERF_EVENT,
	BPF_PROG_TYPE_CGROUP_SKB,
	BPF_PROG_TYPE_CGROUP_SOCK,
	BPF_PROG_TYPE_LWT_IN,
	BPF_PROG_TYPE_LWT_OUT,
	BPF_PROG_TYPE_LWT_XMIT,
	BPF_PROG_TYPE_SOCK_OPS,
	BPF_PROG_TYPE_SK_SKB,
	BPF_PROG_TYPE_CGROUP_DEVICE,
	BPF_PROG_TYPE_SK_MSG,
	BPF_PROG_TYPE_RAW_TRACEPOINT,
	BPF_PROG_TYPE_CGROUP_SOCK_ADDR,
	BPF_PROG_TYPE_LWT_SEG6LOCAL,
	BPF_PROG_TYPE_LIRC_MODE2,
	BPF_PROG_TYPE_SK_REUSEPORT,
	BPF_PROG_TYPE_FLOW_DISSECTOR,
};
</code></pre><p>And here are the map types:</p><pre tabindex=0><code>enum bpf_map_type {
	BPF_MAP_TYPE_UNSPEC,
	BPF_MAP_TYPE_HASH,
	BPF_MAP_TYPE_ARRAY,
	BPF_MAP_TYPE_PROG_ARRAY,
	BPF_MAP_TYPE_PERF_EVENT_ARRAY,
	BPF_MAP_TYPE_PERCPU_HASH,
	BPF_MAP_TYPE_PERCPU_ARRAY,
	BPF_MAP_TYPE_STACK_TRACE,
	BPF_MAP_TYPE_CGROUP_ARRAY,
	BPF_MAP_TYPE_LRU_HASH,
	BPF_MAP_TYPE_LRU_PERCPU_HASH,
	BPF_MAP_TYPE_LPM_TRIE,
	BPF_MAP_TYPE_ARRAY_OF_MAPS,
	BPF_MAP_TYPE_HASH_OF_MAPS,
	BPF_MAP_TYPE_DEVMAP,
	BPF_MAP_TYPE_SOCKMAP,
	BPF_MAP_TYPE_CPUMAP,
	BPF_MAP_TYPE_XSKMAP,
	BPF_MAP_TYPE_SOCKHASH,
	BPF_MAP_TYPE_CGROUP_STORAGE,
	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,
	BPF_MAP_TYPE_QUEUE,
	BPF_MAP_TYPE_STACK,
};
</code></pre><p>As you can see there are many types of maps and programs. For tracing, KPROBE
and TRACEPOINT program types are most useful. For map types, the array and hash
types are useful depending on how you want to manage memory between user and
kernel space.</p><p>For a high-performance buffer one could use an array type. For even more
performance that array could have a single element and data could be read from
within offsets of that single element.</p><p>To share this map with userspace one can also use <code>bpf_obj_pin</code> and
<code>bpf_obj_get</code> to allow a userspace program to access the memory through a file
descriptor.</p><h2 id=features-supported-in-linux-kernel-versions>Features Supported in Linux Kernel Versions</h2><p>A very comprehensive document can be found <a href=https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md>here</a> outlining the various
features and which kernel versions they were supported in. Below are a few
highlights.</p><ul><li>BPF JIT compilation <code>3.16</code></li><li>BPF syscall <code>3.18</code></li><li>BPF attach to kprobes <code>4.1</code></li><li><code>BPF_OBJ_PIN and BPF_OBJ_GET</code> <code>4.4</code></li><li><code>BPF_MAP_TYPE_PERCPU_ARRAY</code> <code>4.6</code></li><li>BPF attach to tracepoints <code>4.7</code></li><li>BPF attach to raw tracepoints <code>4.17</code></li></ul><h2 id=limitations>Limitations</h2><p>Here I&rsquo;ll highlight some limitations versus using a kernel module to trace
system calls.</p><h1 id=in-general>In general</h1><ul><li>Cannot call exported kernel functions</li><li>Cannot access arbitrary memory (need to use helper functions)</li><li>Memory dereferencing requires <code>bpf_probe_read</code></li><li>Performance overhead (although minimized with raw tracepoints)</li><li>Program must terminate and cannot have &lsquo;infinite&rsquo; loops</li></ul><h1 id=fd-to-pathname-mapping>FD to pathname mapping</h1><p>When tracing syscalls it is useful to determine the full path that a particular
syscall is operating on. For example of <code>openat</code>is called, on exit it returns
a file descriptor value which refers to a file. To get the fullpath we can
either construct it from &lsquo;dirfd&rsquo;, &lsquo;pathname&rsquo;, and &lsquo;cwd&rsquo; depending on a few
rules or we can inquire the fullpath directly from the file descriptor. To
construct the fullpath we can use a function like <code>user_path_at</code>, however BPF
does not allow for calling of exported kernel functions. So this means
some duplication of lookup code here. <a href=https://github.com/iovisor/bcc/issues/237>Others</a> have hit this point, and one
could use some shortcuts to get the name via dentry but it is far from
complete.</p><h1 id=peer-sockaddr-lookup>Peer Sockaddr Lookup</h1><p>Determining the peer socket during socket operations is critical for figuring
out the other side of a particular connection. When using BPF this isn&rsquo;t
impossible, but requires some traversal of various memory structures. It seems
that whenever you need to lookup a memory address one needs to call
<code>bpf_probe_read</code>. So something like ptr->-ptr->-ptr would need multiple calls
to deference.</p><h2 id=bpf-tracing-performance>BPF Tracing Performance</h2><p>To understand how BPF can be used for tracing, it is important to review how
tracing can be done in the Linux kernel in the first place! Over the course
of the Linux kernel&rsquo;s development there have been various tracing subsystems
added to solve different problems.</p><p>More details can be found in a previous blog post <a href=http://chrisarges.net/2018/10/04/tracing-in-linux.html>here</a>.</p><p>Sysdig has both a kernel module ring-buffer and BPF tracing solution and has
done a comparison of performance based on various benchmarks. Here a benchmark
that runs many syscalls <a href=https://sysdig.com/blog/sysdig-and-falco-now-powered-by-ebpf/>shows</a> at worst 33% increase in instrumentation
overhead. The difficulty with this study is understanding this at a per syscall
level as some benchmarks may use more syscalls and thus have more overhead. In
addition where is the performance bottleneck? Is it in the copying of event
data into the ring buffer, or is it elsewhere? I believe this study was using
&rsquo;normal&rsquo; bpf tracepoints and not raw tracepoints.</p><p>In a patchset <a href=https://lwn.net/Articles/748352/>here</a> there was a comparison of kprobes to tracepoints to
raw_tracepoints done which show that raw tracepoints have very close to base
performance (10% instrumentation overhead in a worst case).</p><pre tabindex=0><code>tracepoint    base  kprobe+bpf tracepoint+bpf raw_tracepoint+bpf
task_rename   1.1M   769K        947K            1.0M
urandom_read  789K   697K        750K            755K
</code></pre><h1 id=references>References</h1><ul><li><a href=http://man7.org/linux/man-pages/man2/bpf.2.html>http://man7.org/linux/man-pages/man2/bpf.2.html</a></li><li><a href=https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md>https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md</a></li><li><a href=https://github.com/iovisor/bcc>https://github.com/iovisor/bcc</a></li><li><a href=https://sysdig.com/blog/sysdig-and-falco-now-powered-by-ebpf/>https://sysdig.com/blog/sysdig-and-falco-now-powered-by-ebpf/</a></li><li><a href=http://chrisarges.net/2018/10/04/tracing-in-linux.html>http://chrisarges.net/2018/10/04/tracing-in-linux.html</a></li><li><a href=https://lwn.net/Articles/748352/>https://lwn.net/Articles/748352/</a></li><li><a href=https://github.com/iovisor/bcc/issues/237>https://github.com/iovisor/bcc/issues/237</a></li><li><a href=https://ferrisellis.com/posts/ebpf_past_present_future/>https://ferrisellis.com/posts/ebpf_past_present_future/</a></li><li><a href=https://ferrisellis.com/posts/ebpf_syscall_and_maps/>https://ferrisellis.com/posts/ebpf_syscall_and_maps/</a></li><li><a href=https://github.com/zoidbergwill/awesome-ebpf>https://github.com/zoidbergwill/awesome-ebpf</a></li><li><a href=http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html>http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html</a></li><li><a href=https://qmonnet.github.io/whirl-offload/2016/09/01/dive-into-bpf/>https://qmonnet.github.io/whirl-offload/2016/09/01/dive-into-bpf/</a></li><li><a href=https://github.com/cilium/cilium/blob/master/Documentation/bpf.rst>https://github.com/cilium/cilium/blob/master/Documentation/bpf.rst</a></li></ul></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=chrisarges.net/>Home</a></li><li><a href=chrisarges.net/about>About</a></li></ul></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f" aria-label=Facebook><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&text=bpf%20for%20linux%20tracing" aria-label=Twitter><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&title=bpf%20for%20linux%20tracing" aria-label=Linkedin><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&is_video=false&description=bpf%20for%20linux%20tracing" aria-label=Pinterest><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=bpf%20for%20linux%20tracing&body=Check out this article: chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f" aria-label=Email><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&title=bpf%20for%20linux%20tracing" aria-label=Pocket><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&title=bpf%20for%20linux%20tracing" aria-label=reddit><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&name=bpf%20for%20linux%20tracing&description=Overview%20Originally%20called%20eBPF%20for%20extended%20Berkeley%20Packet%20Filter%2c%20BPF%20is%20an%20in-kernel%20bytecode%20interpreter%20that%20is%20very%20multi-purpose.%20In%20this%20post%2c%20I%26rsquo%3bm%20going%20to%20focus%20on%20its%20tracing%20capabilities.%0aTo%20use%20BPF%20one%20can%20use%20the%20bpf%20syscall.%20This%20provides%20a%20way%20to%20both%20load%20BPF%20bytecode%20programs%20and%20also%20create%20memory%20maps%20for%20sharing%20data%20between%20kernel%20and%20user%20space.%0aBecause%20of%20the%20complexity%2c%20using%20bpf%20in%20a%20DIY%20method%20becomes%20a%20bit%20complex." aria-label=Tumblr><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=chrisarges.net%2fposts%2f2019-03-21-bpf-for-tracing%2f&t=bpf%20for%20linux%20tracing" aria-label="Hacker News"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu-toggle class=icon href=# onclick='return $("#nav-footer").toggle(),!1' aria-label=Menu><i class="fas fa-bars fa-lg" aria-hidden=true></i> Menu</a>
<a id=share-toggle class=icon href=# onclick='return $("#share-footer").toggle(),!1' aria-label=Share><i class="fas fa-share-alt fa-lg" aria-hidden=true></i> share</a>
<a id=top style=display:none class=icon href=# onclick='$("html, body").animate({scrollTop:0},"fast")' aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i> Top</a></div></div></div><footer id=footer><div class=footer-left>Copyright &copy; 2023 Chris J Arges</div><div class=footer-right><nav><ul><li><a href=chrisarges.net/>Home</a></li><li><a href=chrisarges.net/about>About</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
<script src=/chrisarges.net/js/code-copy.js></script></html>