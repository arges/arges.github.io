<!doctype html><html lang><head><link rel=preload href=/chrisarges.net/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/chrisarges.net/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/chrisarges.net/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/chrisarges.net/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><script type=text/javascript src=https://latest.cactus.chat/cactus.js></script>
<link rel=stylesheet href=https://latest.cactus.chat/style.css type=text/css><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>tracing in linux |</title><link rel=canonical href=chrisarges.net/posts/2018-10-04-tracing-in-linux/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="tracing in linux"><meta property="og:description" content="Tracing in Linux is robust, flexible and has many options. So what mechanisms exist both in kernel and user space for instrumenting the kernel? In addition what is available in which kernel version, and what requirements does each technology require? Here we&rsquo;ll mostly focus on syscall tracing.
Overview A great overview on Linux tracing systems can be found here. Overall thinking about tracing systems as data sources (in kernel), and frontends help explain why there are so many tools."><meta property="og:type" content="article"><meta property="og:url" content="chrisarges.net/posts/2018-10-04-tracing-in-linux/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-10-04T09:39:10-05:00"><meta property="article:modified_time" content="2018-10-04T09:39:10-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="tracing in linux"><meta name=twitter:description content="Tracing in Linux is robust, flexible and has many options. So what mechanisms exist both in kernel and user space for instrumenting the kernel? In addition what is available in which kernel version, and what requirements does each technology require? Here we&rsquo;ll mostly focus on syscall tracing.
Overview A great overview on Linux tracing systems can be found here. Overall thinking about tracing systems as data sources (in kernel), and frontends help explain why there are so many tools."><link rel=stylesheet href=/chrisarges.net/css/styles.c05d68261bf086a9d7713c4f8a6215a3601608e267a816a7ee58f139b3d1aae51222aae2081c8e0c6bd35e1334773b7a16283022f31f92afd93bb37e5e822e66.css integrity="sha512-wF1oJhvwhqnXcTxPimIVo2AWCOJnqBan7ljxObPRquUSIqriCByODGvTXhM0dzt6FigwIvMfkq/ZO7N+XoIuZg=="><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=chrisarges.net/images/favicon.ico></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=top-icon-tablet href=# onclick='$("html, body").animate({scrollTop:0},"fast")' style=display:none aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg"></i></a>
<span id=menu><span id=nav><ul><li><a href=chrisarges.net/>Home</a></li><li><a href=chrisarges.net/about>About</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=chrisarges.net/posts/2018-02-15-using-sed-encryption-on-disks/ aria-label=Previous><i class="fas fa-chevron-left" aria-hidden=true onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class=icon href=chrisarges.net/posts/2019-01-14-the-magic-of-linux-clone/ aria-label=Next><i class="fas fa-chevron-right" aria-hidden=true onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class=icon href=# onclick='$("html, body").animate({scrollTop:0},"fast")' aria-label="Top of Page"><i class="fas fa-chevron-up" aria-hidden=true onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class=icon href=# aria-label=Share><i class="fas fa-share-alt" aria-hidden=true onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f" aria-label=Facebook><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&text=tracing%20in%20linux" aria-label=Twitter><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&title=tracing%20in%20linux" aria-label=Linkedin><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&is_video=false&description=tracing%20in%20linux" aria-label=Pinterest><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=tracing%20in%20linux&body=Check out this article: chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f" aria-label=Email><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&title=tracing%20in%20linux" aria-label=Pocket><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&title=tracing%20in%20linux" aria-label=reddit><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&name=tracing%20in%20linux&description=Tracing%20in%20Linux%20is%20robust%2c%20flexible%20and%20has%20many%20options.%20So%20what%20mechanisms%20exist%20both%20in%20kernel%20and%20user%20space%20for%20instrumenting%20the%20kernel%3f%20In%20addition%20what%20is%20available%20in%20which%20kernel%20version%2c%20and%20what%20requirements%20does%20each%20technology%20require%3f%20Here%20we%26rsquo%3bll%20mostly%20focus%20on%20syscall%20tracing.%0aOverview%20A%20great%20overview%20on%20Linux%20tracing%20systems%20can%20be%20found%20here.%20Overall%20thinking%20about%20tracing%20systems%20as%20data%20sources%20%28in%20kernel%29%2c%20and%20frontends%20help%20explain%20why%20there%20are%20so%20many%20tools." aria-label=Tumblr><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&t=tracing%20in%20linux" aria-label="Hacker News"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">tracing in linux</h1><div class=meta><div class=postdate><time datetime="2018-10-04 09:39:10 -0500 -0500" itemprop=datePublished>2018-10-04</time></div><div class=article-tag><i class="fas fa-tag"></i>
<a class=tag-link href=/tags/linux rel=tag>linux</a>
,
<a class=tag-link href=/tags/kernel rel=tag>kernel</a>
,
<a class=tag-link href=/tags/tracing rel=tag>tracing</a></div></div></header><div id=toc><nav id=TableOfContents><ul><li><a href=#overview>Overview</a></li><li><a href=#tracepoint>Tracepoint</a></li><li><a href=#ftrace>Ftrace</a></li><li><a href=#kprobes>Kprobes</a></li><li><a href=#ebpf>eBPF</a></li><li><a href=#frontends>Frontends</a></li></ul></nav></div><div class=content itemprop=articleBody><p>Tracing in Linux is robust, flexible and has many options. So what mechanisms
exist both in kernel and user space for instrumenting the kernel? In addition
what is available in which kernel version, and what requirements does each
technology require? Here we&rsquo;ll mostly focus on syscall tracing.</p><h2 id=overview>Overview</h2><p>A great overview on Linux tracing systems can be found <a href=https://jvns.ca/blog/2017/07/05/linux-tracing-systems/>here</a>. Overall
thinking about tracing systems as data sources (in kernel), and frontends help
explain why there are so many tools. Some data sources are &rsquo;tracepoints&rsquo; while
other are &lsquo;probes&rsquo;. Tracepoints are low-overhead and can be activated or
deactivated, they are compiled into the kernel so they cannot be dynamically
instrumented. Probes are very flexible, but require larger overhead as you are
replacing a &rsquo;nop&rsquo; instruction with a branch in order to redirect execution of
probed function. In addition you must know the function name and can only
instrument &lsquo;real&rsquo; (non-inlined) functions. Some good slides describing this are
<a href=https://blog.linuxplumbersconf.org/2014/ocw/system/presentations/1773/original/ftrace-kernel-hooks-2014.pdf>here</a>. Other overviews of tracing technologies can be found <a href=http://www.brendangregg.com/blog/2015-07-08/choosing-a-linux-tracer.html>here</a>.</p><h2 id=tracepoint>Tracepoint</h2><p>Linux kernel <a href=https://www.kernel.org/doc/Documentation/trace/tracepoints.txt>tracepoints</a> allow for a <em>tracepoint</em> to be embedded in
various critical kernel functions. A <em>tracepoint</em> can even be instrumented by a
new kernel module to execute custom code on hitting a <em>tracepoint</em>. This point
makes it very extensible.</p><p>An advantage of tracepoints is they are defined in the code rather than hooking
into a function name. This is important because function names change between
kernel versions as well as parameters.</p><p>Tracepoints are defined in the Linux kernel like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>   <span style=color:#a6e22e>TRACE_EVENT</span>(sched_switch,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>TP_PROTO</span>(<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq, <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>prev,
</span></span><span style=display:flex><span>		 <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>next),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>TP_ARGS</span>(rq, prev, next),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>TP_STRUCT__entry</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>__array</span>(	<span style=color:#66d9ef>char</span>,	prev_comm,	TASK_COMM_LEN	)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>__field</span>(	<span style=color:#66d9ef>pid_t</span>,	prev_pid			)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>__field</span>(	<span style=color:#66d9ef>int</span>,	prev_prio			)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>__field</span>(	<span style=color:#66d9ef>long</span>,	prev_state			)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>__array</span>(	<span style=color:#66d9ef>char</span>,	next_comm,	TASK_COMM_LEN	)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>__field</span>(	<span style=color:#66d9ef>pid_t</span>,	next_pid			)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>__field</span>(	<span style=color:#66d9ef>int</span>,	next_prio			)
</span></span><span style=display:flex><span>	),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>TP_fast_assign</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>memcpy</span>(__entry<span style=color:#f92672>-&gt;</span>next_comm, next<span style=color:#f92672>-&gt;</span>comm, TASK_COMM_LEN);
</span></span><span style=display:flex><span>		__entry<span style=color:#f92672>-&gt;</span>prev_pid	<span style=color:#f92672>=</span> prev<span style=color:#f92672>-&gt;</span>pid;
</span></span><span style=display:flex><span>		__entry<span style=color:#f92672>-&gt;</span>prev_prio	<span style=color:#f92672>=</span> prev<span style=color:#f92672>-&gt;</span>prio;
</span></span><span style=display:flex><span>		__entry<span style=color:#f92672>-&gt;</span>prev_state	<span style=color:#f92672>=</span> prev<span style=color:#f92672>-&gt;</span>state;
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>memcpy</span>(__entry<span style=color:#f92672>-&gt;</span>prev_comm, prev<span style=color:#f92672>-&gt;</span>comm, TASK_COMM_LEN);
</span></span><span style=display:flex><span>		__entry<span style=color:#f92672>-&gt;</span>next_pid	<span style=color:#f92672>=</span> next<span style=color:#f92672>-&gt;</span>pid;
</span></span><span style=display:flex><span>		__entry<span style=color:#f92672>-&gt;</span>next_prio	<span style=color:#f92672>=</span> next<span style=color:#f92672>-&gt;</span>prio;
</span></span><span style=display:flex><span>	),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>TP_printk</span>(<span style=color:#e6db74>&#34;prev_comm=%s prev_pid=%d prev_prio=%d prev_state=%s ==&gt; next_comm=%s next_pid=%d next_prio=%d&#34;</span>,
</span></span><span style=display:flex><span>		__entry<span style=color:#f92672>-&gt;</span>prev_comm, __entry<span style=color:#f92672>-&gt;</span>prev_pid, __entry<span style=color:#f92672>-&gt;</span>prev_prio,
</span></span><span style=display:flex><span>		__entry<span style=color:#f92672>-&gt;</span>prev_state <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>		  <span style=color:#a6e22e>__print_flags</span>(__entry<span style=color:#f92672>-&gt;</span>prev_state, <span style=color:#e6db74>&#34;|&#34;</span>,
</span></span><span style=display:flex><span>				{ <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;S&#34;</span>} , { <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;D&#34;</span> }, { <span style=color:#ae81ff>4</span>, <span style=color:#e6db74>&#34;T&#34;</span> }, { <span style=color:#ae81ff>8</span>, <span style=color:#e6db74>&#34;t&#34;</span> },
</span></span><span style=display:flex><span>				{ <span style=color:#ae81ff>16</span>, <span style=color:#e6db74>&#34;Z&#34;</span> }, { <span style=color:#ae81ff>32</span>, <span style=color:#e6db74>&#34;X&#34;</span> }, { <span style=color:#ae81ff>64</span>, <span style=color:#e6db74>&#34;x&#34;</span> },
</span></span><span style=display:flex><span>				{ <span style=color:#ae81ff>128</span>, <span style=color:#e6db74>&#34;W&#34;</span> }) <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;R&#34;</span>,
</span></span><span style=display:flex><span>		__entry<span style=color:#f92672>-&gt;</span>next_comm, __entry<span style=color:#f92672>-&gt;</span>next_pid, __entry<span style=color:#f92672>-&gt;</span>next_prio)
</span></span><span style=display:flex><span>   );
</span></span></code></pre></div><p>The name <code>sched_switch</code> is the name of the tracepoint, and this macro creates a
function called <code>trace_sched_switch</code> which needs to be added into the desired
Linux function to be traced. More info can be found <a href=https://lwn.net/Articles/379903/>here</a>.</p><p>This interface has been in the kernel a long time and new tracepoints are being
added with every release. More fundamental tracepoints have been added in much
older kernels. For example, the <code>trace_sched_switch</code> function was added the
kernel by <code>0a16b60758433</code> which was released in v2.6.28. The
<code>trace_syscall_enter</code> and <code>trace_syscall_exit</code> functions were added by
<code>a871bd33a6c</code> which was released in v2.6.32.</p><p>These tracepoints can be accessed via <code>ftrace</code> tracefs filesystem, for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># echo 1 &gt; /sys/kernel/debug/tracing/events/syscalls/sys_enter_open</span>
</span></span><span style=display:flex><span><span style=color:#75715e># cat /sys/kernel/debug/tracing/trace_pipe</span>
</span></span><span style=display:flex><span> systemd-journal-365   <span style=color:#f92672>[</span>000<span style=color:#f92672>]</span> .... 88393.862127: sys_open<span style=color:#f92672>(</span>filename: 55f45105d8a0, flags: 80042, mode: 1a0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> systemd-journal-365   <span style=color:#f92672>[</span>000<span style=color:#f92672>]</span> .... 88393.862597: sys_open<span style=color:#f92672>(</span>filename: 7fffdddb2cf0, flags: 90800, mode: 7fffdddb2d21<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> systemd-journal-365   <span style=color:#f92672>[</span>000<span style=color:#f92672>]</span> .... 88393.862665: sys_open<span style=color:#f92672>(</span>filename: 7fffdddb2f40, flags: 90800, mode: 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            bash-18684 <span style=color:#f92672>[</span>000<span style=color:#f92672>]</span> .... 88393.864513: sys_open<span style=color:#f92672>(</span>filename: 1158488, flags: 90800, mode: 118d4c0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            bash-18199 <span style=color:#f92672>[</span>000<span style=color:#f92672>]</span> .... 88393.864996: sys_open<span style=color:#f92672>(</span>filename: 119b008, flags: 2c1, mode: 180<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            bash-18199 <span style=color:#f92672>[</span>000<span style=color:#f92672>]</span> .... 88393.865052: sys_open<span style=color:#f92672>(</span>filename: 119b008, flags: 0, mode: 180<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            bash-18685 <span style=color:#f92672>[</span>000<span style=color:#f92672>]</span> .... 88393.866117: sys_open<span style=color:#f92672>(</span>filename: 1158488, flags: 90800, mode: 118d4c0<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>If you prefer a front-end tool you can use perf to capture specific syscalls for a command:</p><pre tabindex=0><code># perf trace --no-syscalls --event &#39;syscalls:sys_enter_connect&#39; ping 8.8.8.8 -c 1
     1.704 syscalls:sys_enter_connect:fd: 0x00000004, uservaddr: 0x7ffd0bf83e50, addrlen: 0x00000010)
PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
64 bytes from 8.8.8.8: icmp_seq=1 ttl=120 time=19.6 ms

--- 8.8.8.8 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 19.616/19.616/19.616/0.000 ms
</code></pre><p>To trace all syscalls on a system use the following:</p><pre tabindex=0><code># cd /sys/kernel/debug/tracing/
# echo 1 &gt; events/syscalls/enable
# cat trace_pipe
bash-18199 [000] .... 84627.885591: sys_rt_sigaction -&gt; 0x0
bash-18199 [000] .... 84627.885595: sys_rt_sigaction(sig: 2, act: 7ffd9fa6d780, oact: 7ffd9fa6d820, sigsetsize: 8)
bash-18199 [000] .... 84627.885596: sys_rt_sigaction -&gt; 0x0
bash-18199 [000] .... 84627.885682: sys_open(filename: 1125148, flags: 241, mode: 1b6)
bash-18199 [000] .... 84627.885705: sys_open -&gt; 0x3
bash-18199 [000] .... 84627.885709: sys_fcntl(fd: 1, cmd: 1, arg: 0)
bash-18199 [000] .... 84627.885720: sys_fcntl -&gt; 0x0
</code></pre><h2 id=ftrace>Ftrace</h2><p>To see tracepoints we used the tracefs filesystem which is also called
<code>ftrace</code>. See the <a href=https://www.kernel.org/doc/Documentation/trace/ftrace.txt>ftrace</a> document for more exhaustive use of ftrace in
userspace.</p><p>Ftrace itself can use various data sources such as tracepoints and even
function trampolines. The function trampolines are instrumented and configured
via the kernel and utilize gcc&rsquo;s <code>-pg</code> flag for function profiling. This is
very powerful and the basis of kernel livepatching.</p><p>Kernel requirements depend on what information you want to get, for syscalls
<code>HAVE_SYSCALL_TRACEPOINTS</code> (formerly <code>HAVE_FTRACE_SYSCALLS</code>) needs to be
implemented for tracing to work with ftrace. This is architecture
dependent, and for x86 was implemented in v2.6.30. More details can be found in
the <a href=https://www.kernel.org/doc/Documentation/trace/ftrace-design.txt>design</a> document. In addition much of the code for handling syscall
tracing for ftrace is in <code>kernel/trace/trace_syscalls.c</code>.</p><h2 id=kprobes>Kprobes</h2><p>Another interface that can be used via tracefs.</p><p>Example usage:</p><pre tabindex=0><code># echo 1 &gt; /sys/kernel/debug/tracing/tracing_on
# echo &#39;p:myprobe do_sys_open dfd=%ax filename=%dx flags=%cx mode=+4($stack)&#39; &gt;&gt; /sys/kernel/debug/tracing/kprobe_events
# echo 1 &gt; /sys/kernel/debug/tracing/events/kprobes/myprobe/enable
# cat /sys/kernel/debug/tracing/trace
# tracer: nop
#
# entries-in-buffer/entries-written: 4/951007   #P:1
#
#                              _-----=&gt; irqs-off
#                             / _----=&gt; need-resched
#                            | / _---=&gt; hardirq/softirq
#                            || / _--=&gt; preempt-depth
#                            ||| /     delay
#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
#              | |       |   ||||       |         |
             cat-18934 [000] d... 92669.062797: myprobe: (do_sys_open+0x0/0x2a0) dfd=0xffffffff81216050 filename=0x88000 flags=0x1 m
ode=0xffffffffffffffff
             cat-18934 [000] d... 92669.062846: myprobe: (do_sys_open+0x0/0x2a0) dfd=0xffffffff81216050 filename=0x88000 flags=0x316
8 mode=0x18f0c660ffffffff
             cat-18934 [000] d... 92669.063316: myprobe: (do_sys_open+0x0/0x2a0) dfd=0xffffffff81216050 filename=0x88000 flags=0x0 m
ode=0x18f0cae0ffffffff
             cat-18934 [000] d... 92669.063423: myprobe: (do_sys_open+0x0/0x2a0) dfd=0xffffffff81216050 filename=0x8000 flags=0x0 mo
de=0x1000ffffffff
</code></pre><p>The nice thing here is you can print custom parameters, and potentially use
even more sophisticated parsing of said parameters.</p><h2 id=ebpf>eBPF</h2><p>Extended Berkley Packet Filter has been usable for tracing since v4.1, but many
improvements are still ongoing. To use eBPF you write a C program that gets
loaded into the kernel via the BPF syscall. The program has to use specific
functions and cannot have loops. The kernel verifies this before allowing the
code to be executed in kernel. The advantage here is that writing a custom
kernel module is not required and one can attach to tracepoints and do advanced
filtering and instrumentation.</p><p>An example of tracing open syscalls is <a href=https://github.com/torvalds/linux/blob/master/samples/bpf/syscall_tp_kern.c>here</a>.</p><p>More information can be found <a href=https://lwn.net/Articles/740157/>here</a>.</p><h2 id=frontends>Frontends</h2><p>SystemTap, LTTng, and sysdig are all other tracing tools that utilize kernel
functionality ranging from tracepoints to kprobes.</p><p>SystemTap makes it easy to write kprobes for various functions and has its own
high level syntax that can be compiled down into something usable by the
kernel.</p><p>LTTng ships its own kernel module which instruments tracepoints (among many
other things). The <a href=https://lttng.org/docs>webpage</a> has very extensive documentation. Very cool
discussion on their ring buffer design.</p><pre tabindex=0><code># lttng create my-kernel-session --output=/tmp/my-kernel-trace
# lttng list --kernel
# lttng enable-event --kernel --syscall open,close
# lttng start
# lttng stop
# lttng destroy
# babeltrace /tmp/my-kernel-trace
[18:38:35.107903286] (+0.000003918) test syscall_exit_open: { cpu_id = 0 }, { ret = 3 }
[18:38:35.107920793] (+0.000017507) test syscall_entry_close: { cpu_id = 0 }, { fd = 3 }
[18:38:35.107921474] (+0.000000681) test syscall_exit_close: { cpu_id = 0 }, { ret = 0 }
[18:38:35.108280899] (+0.000359425) test syscall_entry_open: { cpu_id = 0 }, { filename = &#34;/usr/lib/python3.5/__pycache__/struct.cpy
thon-35.pyc&#34;, flags = 524288, mode = 438 }
[18:38:35.108284573] (+0.000003674) test syscall_exit_open: { cpu_id = 0 }, { ret = 3 }
[18:38:35.108299173] (+0.000014600) test syscall_entry_close: { cpu_id = 0 }, { fd = 3 }
</code></pre><p>Sysdig is a commercial product that also has an open-source component which is
the kernel module and some user-space tooling. The module registers functions
on various kernel tracepoints, looks up additional information in the kernel,
and injects this into a ring buffer exposed into userspace.</p></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=chrisarges.net/>Home</a></li><li><a href=chrisarges.net/about>About</a></li></ul></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f" aria-label=Facebook><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&text=tracing%20in%20linux" aria-label=Twitter><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&title=tracing%20in%20linux" aria-label=Linkedin><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&is_video=false&description=tracing%20in%20linux" aria-label=Pinterest><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=tracing%20in%20linux&body=Check out this article: chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f" aria-label=Email><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&title=tracing%20in%20linux" aria-label=Pocket><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&title=tracing%20in%20linux" aria-label=reddit><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&name=tracing%20in%20linux&description=Tracing%20in%20Linux%20is%20robust%2c%20flexible%20and%20has%20many%20options.%20So%20what%20mechanisms%20exist%20both%20in%20kernel%20and%20user%20space%20for%20instrumenting%20the%20kernel%3f%20In%20addition%20what%20is%20available%20in%20which%20kernel%20version%2c%20and%20what%20requirements%20does%20each%20technology%20require%3f%20Here%20we%26rsquo%3bll%20mostly%20focus%20on%20syscall%20tracing.%0aOverview%20A%20great%20overview%20on%20Linux%20tracing%20systems%20can%20be%20found%20here.%20Overall%20thinking%20about%20tracing%20systems%20as%20data%20sources%20%28in%20kernel%29%2c%20and%20frontends%20help%20explain%20why%20there%20are%20so%20many%20tools." aria-label=Tumblr><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=chrisarges.net%2fposts%2f2018-10-04-tracing-in-linux%2f&t=tracing%20in%20linux" aria-label="Hacker News"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu-toggle class=icon href=# onclick='return $("#nav-footer").toggle(),!1' aria-label=Menu><i class="fas fa-bars fa-lg" aria-hidden=true></i> Menu</a>
<a id=share-toggle class=icon href=# onclick='return $("#share-footer").toggle(),!1' aria-label=Share><i class="fas fa-share-alt fa-lg" aria-hidden=true></i> share</a>
<a id=top style=display:none class=icon href=# onclick='$("html, body").animate({scrollTop:0},"fast")' aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i> Top</a></div></div></div><footer id=footer><div class=footer-left>Copyright &copy; 2023 Chris J Arges</div><div class=footer-right><nav><ul><li><a href=chrisarges.net/>Home</a></li><li><a href=chrisarges.net/about>About</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
<script src=/chrisarges.net/js/code-copy.js></script></html>